# Generated from /Users/Victor/PycharmProjects/NeuralLog/language/parser/autogenerated/NeuralLog.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\32")
        buf.write("\u0088\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\3\2\3\2")
        buf.write("\6\2\'\n\2\r\2\16\2(\3\3\3\3\3\3\3\3\3\3\5\3\60\n\3\3")
        buf.write("\3\3\3\3\3\3\3\3\4\3\4\3\4\5\49\n\4\3\4\3\4\3\5\3\5\5")
        buf.write("\5?\n\5\3\6\6\6B\n\6\r\6\16\6C\3\7\3\7\3\7\3\7\3\7\3\b")
        buf.write("\3\b\3\b\5\bN\n\b\3\t\3\t\3\t\7\tS\n\t\f\t\16\tV\13\t")
        buf.write("\3\n\5\nY\n\n\3\n\5\n\\\n\n\3\n\3\n\3\13\3\13\3\13\3\13")
        buf.write("\7\13d\n\13\f\13\16\13g\13\13\3\13\3\13\3\f\3\f\5\fm\n")
        buf.write("\f\3\r\3\r\6\rq\n\r\r\r\16\rr\5\ru\n\r\3\16\3\16\3\17")
        buf.write("\6\17z\n\17\r\17\16\17{\3\20\3\20\3\21\3\21\3\21\3\21")
        buf.write("\3\21\3\21\3\22\3\22\3\22\2\2\23\2\4\6\b\n\f\16\20\22")
        buf.write("\24\26\30\32\34\36 \"\2\5\3\2\16\17\4\2\13\16\27\27\3")
        buf.write("\2\13\r\2\u0086\2&\3\2\2\2\4*\3\2\2\2\68\3\2\2\2\b<\3")
        buf.write("\2\2\2\nA\3\2\2\2\fE\3\2\2\2\16J\3\2\2\2\20O\3\2\2\2\22")
        buf.write("X\3\2\2\2\24_\3\2\2\2\26l\3\2\2\2\30t\3\2\2\2\32v\3\2")
        buf.write("\2\2\34y\3\2\2\2\36}\3\2\2\2 \177\3\2\2\2\"\u0085\3\2")
        buf.write("\2\2$\'\5\4\3\2%\'\5\6\4\2&$\3\2\2\2&%\3\2\2\2\'(\3\2")
        buf.write("\2\2(&\3\2\2\2()\3\2\2\2)\3\3\2\2\2*+\7\6\2\2+,\5\32\16")
        buf.write("\2,/\7\7\2\2-\60\5\34\17\2.\60\5 \21\2/-\3\2\2\2/.\3\2")
        buf.write("\2\2\60\61\3\2\2\2\61\62\7\b\2\2\62\63\5\2\2\2\63\64\7")
        buf.write("\t\2\2\64\5\3\2\2\2\659\5\b\5\2\669\5\f\7\2\679\5\16\b")
        buf.write("\28\65\3\2\2\28\66\3\2\2\28\67\3\2\2\29:\3\2\2\2:;\7\23")
        buf.write("\2\2;\7\3\2\2\2<>\5\n\6\2=?\5\24\13\2>=\3\2\2\2>?\3\2")
        buf.write("\2\2?\t\3\2\2\2@B\t\2\2\2A@\3\2\2\2BC\3\2\2\2CA\3\2\2")
        buf.write("\2CD\3\2\2\2D\13\3\2\2\2EF\5\"\22\2FG\7\24\2\2GH\3\2\2")
        buf.write("\2HI\5\b\5\2I\r\3\2\2\2JK\5\b\5\2KM\7\25\2\2LN\5\20\t")
        buf.write("\2ML\3\2\2\2MN\3\2\2\2N\17\3\2\2\2OT\5\22\n\2PQ\7\22\2")
        buf.write("\2QS\5\22\n\2RP\3\2\2\2SV\3\2\2\2TR\3\2\2\2TU\3\2\2\2")
        buf.write("U\21\3\2\2\2VT\3\2\2\2WY\7\n\2\2XW\3\2\2\2XY\3\2\2\2Y")
        buf.write("[\3\2\2\2Z\\\7\26\2\2[Z\3\2\2\2[\\\3\2\2\2\\]\3\2\2\2")
        buf.write("]^\5\b\5\2^\23\3\2\2\2_`\7\20\2\2`e\5\26\f\2ab\7\22\2")
        buf.write("\2bd\5\26\f\2ca\3\2\2\2dg\3\2\2\2ec\3\2\2\2ef\3\2\2\2")
        buf.write("fh\3\2\2\2ge\3\2\2\2hi\7\21\2\2i\25\3\2\2\2jm\5\"\22\2")
        buf.write("km\5\30\r\2lj\3\2\2\2lk\3\2\2\2m\27\3\2\2\2nu\7\27\2\2")
        buf.write("oq\t\2\2\2po\3\2\2\2qr\3\2\2\2rp\3\2\2\2rs\3\2\2\2su\3")
        buf.write("\2\2\2tn\3\2\2\2tp\3\2\2\2u\31\3\2\2\2vw\7\16\2\2w\33")
        buf.write("\3\2\2\2xz\5\36\20\2yx\3\2\2\2z{\3\2\2\2{y\3\2\2\2{|\3")
        buf.write("\2\2\2|\35\3\2\2\2}~\t\3\2\2~\37\3\2\2\2\177\u0080\7\3")
        buf.write("\2\2\u0080\u0081\7\r\2\2\u0081\u0082\7\4\2\2\u0082\u0083")
        buf.write("\7\r\2\2\u0083\u0084\7\5\2\2\u0084!\3\2\2\2\u0085\u0086")
        buf.write("\t\4\2\2\u0086#\3\2\2\2\21&(/8>CMTX[elrt{")
        return buf.getvalue()


class NeuralLogParser ( Parser ):

    grammarFileName = "NeuralLog.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'{'", "'..'", "'}'", "'for'", "'in'", 
                     "'do'", "'done'", "'not'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'('", "')'", 
                     "','", "'.'", "'::'", "':-'", "'$'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "FOR_LOOP", "IN_TOKEN", "DO_TOKEN", "DONE_TOKEN", 
                      "NEGATION", "SCIENTIFIC_NUMBER", "DECIMAL", "INTEGER", 
                      "TERM", "PLACE_HOLDER", "OPEN_ARGUMENTS", "CLOSE_ARGUMENTS", 
                      "ITEM_SEPARATOR", "END_OF_CLAUSE", "WEIGHT_SEPARATOR", 
                      "IMPLICATION_SIGN", "TRAINABLE_IDENTIFIER", "QUOTED", 
                      "WHITESPACE", "COMMENT", "BLOCK_COMMENT" ]

    RULE_program = 0
    RULE_for_loop = 1
    RULE_clause = 2
    RULE_atom = 3
    RULE_predicate = 4
    RULE_weighted_atom = 5
    RULE_horn_clause = 6
    RULE_body = 7
    RULE_literal = 8
    RULE_list_of_arguments = 9
    RULE_argument = 10
    RULE_term = 11
    RULE_for_variable = 12
    RULE_for_terms = 13
    RULE_for_term = 14
    RULE_for_range = 15
    RULE_number = 16

    ruleNames =  [ "language", "for_loop", "clause", "atom", "predicate", 
                   "weighted_atom", "horn_clause", "body", "literal", "list_of_arguments", 
                   "argument", "term", "for_variable", "for_terms", "for_term", 
                   "for_range", "number" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    FOR_LOOP=4
    IN_TOKEN=5
    DO_TOKEN=6
    DONE_TOKEN=7
    NEGATION=8
    SCIENTIFIC_NUMBER=9
    DECIMAL=10
    INTEGER=11
    TERM=12
    PLACE_HOLDER=13
    OPEN_ARGUMENTS=14
    CLOSE_ARGUMENTS=15
    ITEM_SEPARATOR=16
    END_OF_CLAUSE=17
    WEIGHT_SEPARATOR=18
    IMPLICATION_SIGN=19
    TRAINABLE_IDENTIFIER=20
    QUOTED=21
    WHITESPACE=22
    COMMENT=23
    BLOCK_COMMENT=24

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def for_loop(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeuralLogParser.For_loopContext)
            else:
                return self.getTypedRuleContext(NeuralLogParser.For_loopContext,i)


        def clause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeuralLogParser.ClauseContext)
            else:
                return self.getTypedRuleContext(NeuralLogParser.ClauseContext,i)


        def getRuleIndex(self):
            return NeuralLogParser.RULE_program




    def program(self):

        localctx = NeuralLogParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 36 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 36
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [NeuralLogParser.FOR_LOOP]:
                    self.state = 34
                    self.for_loop()
                    pass
                elif token in [NeuralLogParser.SCIENTIFIC_NUMBER, NeuralLogParser.DECIMAL, NeuralLogParser.INTEGER, NeuralLogParser.TERM, NeuralLogParser.PLACE_HOLDER]:
                    self.state = 35
                    self.clause()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 38 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << NeuralLogParser.FOR_LOOP) | (1 << NeuralLogParser.SCIENTIFIC_NUMBER) | (1 << NeuralLogParser.DECIMAL) | (1 << NeuralLogParser.INTEGER) | (1 << NeuralLogParser.TERM) | (1 << NeuralLogParser.PLACE_HOLDER))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class For_loopContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR_LOOP(self):
            return self.getToken(NeuralLogParser.FOR_LOOP, 0)

        def for_variable(self):
            return self.getTypedRuleContext(NeuralLogParser.For_variableContext,0)


        def IN_TOKEN(self):
            return self.getToken(NeuralLogParser.IN_TOKEN, 0)

        def DO_TOKEN(self):
            return self.getToken(NeuralLogParser.DO_TOKEN, 0)

        def program(self):
            return self.getTypedRuleContext(NeuralLogParser.ProgramContext,0)


        def DONE_TOKEN(self):
            return self.getToken(NeuralLogParser.DONE_TOKEN, 0)

        def for_terms(self):
            return self.getTypedRuleContext(NeuralLogParser.For_termsContext,0)


        def for_range(self):
            return self.getTypedRuleContext(NeuralLogParser.For_rangeContext,0)


        def getRuleIndex(self):
            return NeuralLogParser.RULE_for_loop




    def for_loop(self):

        localctx = NeuralLogParser.For_loopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_for_loop)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 40
            self.match(NeuralLogParser.FOR_LOOP)
            self.state = 41
            self.for_variable()
            self.state = 42
            self.match(NeuralLogParser.IN_TOKEN)
            self.state = 45
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [NeuralLogParser.SCIENTIFIC_NUMBER, NeuralLogParser.DECIMAL, NeuralLogParser.INTEGER, NeuralLogParser.TERM, NeuralLogParser.QUOTED]:
                self.state = 43
                self.for_terms()
                pass
            elif token in [NeuralLogParser.T__0]:
                self.state = 44
                self.for_range()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 47
            self.match(NeuralLogParser.DO_TOKEN)
            self.state = 48
            self.program()
            self.state = 49
            self.match(NeuralLogParser.DONE_TOKEN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def END_OF_CLAUSE(self):
            return self.getToken(NeuralLogParser.END_OF_CLAUSE, 0)

        def atom(self):
            return self.getTypedRuleContext(NeuralLogParser.AtomContext,0)


        def weighted_atom(self):
            return self.getTypedRuleContext(NeuralLogParser.Weighted_atomContext,0)


        def horn_clause(self):
            return self.getTypedRuleContext(NeuralLogParser.Horn_clauseContext,0)


        def getRuleIndex(self):
            return NeuralLogParser.RULE_clause




    def clause(self):

        localctx = NeuralLogParser.ClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 54
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 51
                self.atom()
                pass

            elif la_ == 2:
                self.state = 52
                self.weighted_atom()
                pass

            elif la_ == 3:
                self.state = 53
                self.horn_clause()
                pass


            self.state = 56
            self.match(NeuralLogParser.END_OF_CLAUSE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predicate(self):
            return self.getTypedRuleContext(NeuralLogParser.PredicateContext,0)


        def list_of_arguments(self):
            return self.getTypedRuleContext(NeuralLogParser.List_of_argumentsContext,0)


        def getRuleIndex(self):
            return NeuralLogParser.RULE_atom




    def atom(self):

        localctx = NeuralLogParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_atom)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 58
            self.predicate()
            self.state = 60
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==NeuralLogParser.OPEN_ARGUMENTS:
                self.state = 59
                self.list_of_arguments()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLACE_HOLDER(self, i:int=None):
            if i is None:
                return self.getTokens(NeuralLogParser.PLACE_HOLDER)
            else:
                return self.getToken(NeuralLogParser.PLACE_HOLDER, i)

        def TERM(self, i:int=None):
            if i is None:
                return self.getTokens(NeuralLogParser.TERM)
            else:
                return self.getToken(NeuralLogParser.TERM, i)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_predicate




    def predicate(self):

        localctx = NeuralLogParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_predicate)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 63 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 62
                _la = self._input.LA(1)
                if not(_la==NeuralLogParser.TERM or _la==NeuralLogParser.PLACE_HOLDER):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 65 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==NeuralLogParser.TERM or _la==NeuralLogParser.PLACE_HOLDER):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Weighted_atomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(NeuralLogParser.AtomContext,0)


        def number(self):
            return self.getTypedRuleContext(NeuralLogParser.NumberContext,0)


        def WEIGHT_SEPARATOR(self):
            return self.getToken(NeuralLogParser.WEIGHT_SEPARATOR, 0)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_weighted_atom




    def weighted_atom(self):

        localctx = NeuralLogParser.Weighted_atomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_weighted_atom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 67
            self.number()
            self.state = 68
            self.match(NeuralLogParser.WEIGHT_SEPARATOR)
            self.state = 70
            self.atom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Horn_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(NeuralLogParser.AtomContext,0)


        def IMPLICATION_SIGN(self):
            return self.getToken(NeuralLogParser.IMPLICATION_SIGN, 0)

        def body(self):
            return self.getTypedRuleContext(NeuralLogParser.BodyContext,0)


        def getRuleIndex(self):
            return NeuralLogParser.RULE_horn_clause




    def horn_clause(self):

        localctx = NeuralLogParser.Horn_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_horn_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 72
            self.atom()
            self.state = 73
            self.match(NeuralLogParser.IMPLICATION_SIGN)
            self.state = 75
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << NeuralLogParser.NEGATION) | (1 << NeuralLogParser.TERM) | (1 << NeuralLogParser.PLACE_HOLDER) | (1 << NeuralLogParser.TRAINABLE_IDENTIFIER))) != 0):
                self.state = 74
                self.body()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeuralLogParser.LiteralContext)
            else:
                return self.getTypedRuleContext(NeuralLogParser.LiteralContext,i)


        def ITEM_SEPARATOR(self, i:int=None):
            if i is None:
                return self.getTokens(NeuralLogParser.ITEM_SEPARATOR)
            else:
                return self.getToken(NeuralLogParser.ITEM_SEPARATOR, i)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_body




    def body(self):

        localctx = NeuralLogParser.BodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 77
            self.literal()
            self.state = 82
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==NeuralLogParser.ITEM_SEPARATOR:
                self.state = 78
                self.match(NeuralLogParser.ITEM_SEPARATOR)
                self.state = 79
                self.literal()
                self.state = 84
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(NeuralLogParser.AtomContext,0)


        def NEGATION(self):
            return self.getToken(NeuralLogParser.NEGATION, 0)

        def TRAINABLE_IDENTIFIER(self):
            return self.getToken(NeuralLogParser.TRAINABLE_IDENTIFIER, 0)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_literal




    def literal(self):

        localctx = NeuralLogParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==NeuralLogParser.NEGATION:
                self.state = 85
                self.match(NeuralLogParser.NEGATION)


            self.state = 89
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==NeuralLogParser.TRAINABLE_IDENTIFIER:
                self.state = 88
                self.match(NeuralLogParser.TRAINABLE_IDENTIFIER)


            self.state = 91
            self.atom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class List_of_argumentsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_ARGUMENTS(self):
            return self.getToken(NeuralLogParser.OPEN_ARGUMENTS, 0)

        def argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeuralLogParser.ArgumentContext)
            else:
                return self.getTypedRuleContext(NeuralLogParser.ArgumentContext,i)


        def CLOSE_ARGUMENTS(self):
            return self.getToken(NeuralLogParser.CLOSE_ARGUMENTS, 0)

        def ITEM_SEPARATOR(self, i:int=None):
            if i is None:
                return self.getTokens(NeuralLogParser.ITEM_SEPARATOR)
            else:
                return self.getToken(NeuralLogParser.ITEM_SEPARATOR, i)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_list_of_arguments




    def list_of_arguments(self):

        localctx = NeuralLogParser.List_of_argumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_list_of_arguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            self.match(NeuralLogParser.OPEN_ARGUMENTS)
            self.state = 94
            self.argument()
            self.state = 99
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==NeuralLogParser.ITEM_SEPARATOR:
                self.state = 95
                self.match(NeuralLogParser.ITEM_SEPARATOR)
                self.state = 96
                self.argument()
                self.state = 101
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 102
            self.match(NeuralLogParser.CLOSE_ARGUMENTS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self):
            return self.getTypedRuleContext(NeuralLogParser.NumberContext,0)


        def term(self):
            return self.getTypedRuleContext(NeuralLogParser.TermContext,0)


        def getRuleIndex(self):
            return NeuralLogParser.RULE_argument




    def argument(self):

        localctx = NeuralLogParser.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_argument)
        try:
            self.state = 106
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [NeuralLogParser.SCIENTIFIC_NUMBER, NeuralLogParser.DECIMAL, NeuralLogParser.INTEGER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 104
                self.number()
                pass
            elif token in [NeuralLogParser.TERM, NeuralLogParser.PLACE_HOLDER, NeuralLogParser.QUOTED]:
                self.enterOuterAlt(localctx, 2)
                self.state = 105
                self.term()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUOTED(self):
            return self.getToken(NeuralLogParser.QUOTED, 0)

        def PLACE_HOLDER(self, i:int=None):
            if i is None:
                return self.getTokens(NeuralLogParser.PLACE_HOLDER)
            else:
                return self.getToken(NeuralLogParser.PLACE_HOLDER, i)

        def TERM(self, i:int=None):
            if i is None:
                return self.getTokens(NeuralLogParser.TERM)
            else:
                return self.getToken(NeuralLogParser.TERM, i)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_term




    def term(self):

        localctx = NeuralLogParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_term)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 114
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [NeuralLogParser.QUOTED]:
                self.state = 108
                self.match(NeuralLogParser.QUOTED)
                pass
            elif token in [NeuralLogParser.TERM, NeuralLogParser.PLACE_HOLDER]:
                self.state = 110 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 109
                    _la = self._input.LA(1)
                    if not(_la==NeuralLogParser.TERM or _la==NeuralLogParser.PLACE_HOLDER):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 112 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==NeuralLogParser.TERM or _la==NeuralLogParser.PLACE_HOLDER):
                        break

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class For_variableContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TERM(self):
            return self.getToken(NeuralLogParser.TERM, 0)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_for_variable




    def for_variable(self):

        localctx = NeuralLogParser.For_variableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_for_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 116
            self.match(NeuralLogParser.TERM)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class For_termsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def for_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeuralLogParser.For_termContext)
            else:
                return self.getTypedRuleContext(NeuralLogParser.For_termContext,i)


        def getRuleIndex(self):
            return NeuralLogParser.RULE_for_terms




    def for_terms(self):

        localctx = NeuralLogParser.For_termsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_for_terms)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 118
                self.for_term()
                self.state = 121 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << NeuralLogParser.SCIENTIFIC_NUMBER) | (1 << NeuralLogParser.DECIMAL) | (1 << NeuralLogParser.INTEGER) | (1 << NeuralLogParser.TERM) | (1 << NeuralLogParser.QUOTED))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class For_termContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TERM(self):
            return self.getToken(NeuralLogParser.TERM, 0)

        def QUOTED(self):
            return self.getToken(NeuralLogParser.QUOTED, 0)

        def SCIENTIFIC_NUMBER(self):
            return self.getToken(NeuralLogParser.SCIENTIFIC_NUMBER, 0)

        def DECIMAL(self):
            return self.getToken(NeuralLogParser.DECIMAL, 0)

        def INTEGER(self):
            return self.getToken(NeuralLogParser.INTEGER, 0)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_for_term




    def for_term(self):

        localctx = NeuralLogParser.For_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_for_term)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << NeuralLogParser.SCIENTIFIC_NUMBER) | (1 << NeuralLogParser.DECIMAL) | (1 << NeuralLogParser.INTEGER) | (1 << NeuralLogParser.TERM) | (1 << NeuralLogParser.QUOTED))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class For_rangeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER(self, i:int=None):
            if i is None:
                return self.getTokens(NeuralLogParser.INTEGER)
            else:
                return self.getToken(NeuralLogParser.INTEGER, i)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_for_range




    def for_range(self):

        localctx = NeuralLogParser.For_rangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_for_range)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            self.match(NeuralLogParser.T__0)
            self.state = 126
            self.match(NeuralLogParser.INTEGER)
            self.state = 127
            self.match(NeuralLogParser.T__1)
            self.state = 128
            self.match(NeuralLogParser.INTEGER)
            self.state = 129
            self.match(NeuralLogParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCIENTIFIC_NUMBER(self):
            return self.getToken(NeuralLogParser.SCIENTIFIC_NUMBER, 0)

        def DECIMAL(self):
            return self.getToken(NeuralLogParser.DECIMAL, 0)

        def INTEGER(self):
            return self.getToken(NeuralLogParser.INTEGER, 0)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_number




    def number(self):

        localctx = NeuralLogParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << NeuralLogParser.SCIENTIFIC_NUMBER) | (1 << NeuralLogParser.DECIMAL) | (1 << NeuralLogParser.INTEGER))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx






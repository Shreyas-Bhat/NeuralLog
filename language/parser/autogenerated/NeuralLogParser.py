# Generated from NeuralLog.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\32")
        buf.write("\u0082\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\3\2\3\2\7\2\37\n\2\f\2\16\2\"\13\2\3\3\3\3\3\3\3")
        buf.write("\3\6\3(\n\3\r\3\16\3)\3\3\3\3\3\3\3\3\3\3\5\3\61\n\3\3")
        buf.write("\3\3\3\3\3\6\3\66\n\3\r\3\16\3\67\3\3\3\3\3\4\3\4\3\4")
        buf.write("\5\4?\n\4\3\4\3\4\3\5\6\5D\n\5\r\5\16\5E\3\5\5\5I\n\5")
        buf.write("\3\6\3\6\3\6\3\6\3\6\3\7\3\7\3\7\5\7S\n\7\3\b\3\b\3\b")
        buf.write("\7\bX\n\b\f\b\16\b[\13\b\3\t\5\t^\n\t\3\t\5\ta\n\t\3\t")
        buf.write("\3\t\3\n\3\n\3\n\3\n\7\ni\n\n\f\n\16\nl\13\n\3\n\3\n\3")
        buf.write("\13\3\13\5\13r\n\13\3\f\3\f\6\fv\n\f\r\f\16\fw\5\fz\n")
        buf.write("\f\3\r\3\r\5\r~\n\r\3\16\3\16\3\16\2\2\17\2\4\6\b\n\f")
        buf.write("\16\20\22\24\26\30\32\2\4\3\2\16\17\3\2\13\r\2\u0087\2")
        buf.write(" \3\2\2\2\4#\3\2\2\2\6>\3\2\2\2\bC\3\2\2\2\nJ\3\2\2\2")
        buf.write("\fO\3\2\2\2\16T\3\2\2\2\20]\3\2\2\2\22d\3\2\2\2\24q\3")
        buf.write("\2\2\2\26y\3\2\2\2\30}\3\2\2\2\32\177\3\2\2\2\34\37\5")
        buf.write("\4\3\2\35\37\5\6\4\2\36\34\3\2\2\2\36\35\3\2\2\2\37\"")
        buf.write("\3\2\2\2 \36\3\2\2\2 !\3\2\2\2!\3\3\2\2\2\" \3\2\2\2#")
        buf.write("$\7\6\2\2$%\7\16\2\2%\60\7\7\2\2&(\5\30\r\2\'&\3\2\2\2")
        buf.write("()\3\2\2\2)\'\3\2\2\2)*\3\2\2\2*\61\3\2\2\2+,\7\3\2\2")
        buf.write(",-\7\r\2\2-.\7\4\2\2./\7\r\2\2/\61\7\5\2\2\60\'\3\2\2")
        buf.write("\2\60+\3\2\2\2\61\62\3\2\2\2\62\65\7\b\2\2\63\66\5\4\3")
        buf.write("\2\64\66\5\6\4\2\65\63\3\2\2\2\65\64\3\2\2\2\66\67\3\2")
        buf.write("\2\2\67\65\3\2\2\2\678\3\2\2\289\3\2\2\29:\7\t\2\2:\5")
        buf.write("\3\2\2\2;?\5\b\5\2<?\5\n\6\2=?\5\f\7\2>;\3\2\2\2><\3\2")
        buf.write("\2\2>=\3\2\2\2?@\3\2\2\2@A\7\23\2\2A\7\3\2\2\2BD\t\2\2")
        buf.write("\2CB\3\2\2\2DE\3\2\2\2EC\3\2\2\2EF\3\2\2\2FH\3\2\2\2G")
        buf.write("I\5\22\n\2HG\3\2\2\2HI\3\2\2\2I\t\3\2\2\2JK\5\32\16\2")
        buf.write("KL\7\24\2\2LM\3\2\2\2MN\5\b\5\2N\13\3\2\2\2OP\5\b\5\2")
        buf.write("PR\7\25\2\2QS\5\16\b\2RQ\3\2\2\2RS\3\2\2\2S\r\3\2\2\2")
        buf.write("TY\5\20\t\2UV\7\22\2\2VX\5\20\t\2WU\3\2\2\2X[\3\2\2\2")
        buf.write("YW\3\2\2\2YZ\3\2\2\2Z\17\3\2\2\2[Y\3\2\2\2\\^\7\n\2\2")
        buf.write("]\\\3\2\2\2]^\3\2\2\2^`\3\2\2\2_a\7\26\2\2`_\3\2\2\2`")
        buf.write("a\3\2\2\2ab\3\2\2\2bc\5\b\5\2c\21\3\2\2\2de\7\20\2\2e")
        buf.write("j\5\24\13\2fg\7\22\2\2gi\5\24\13\2hf\3\2\2\2il\3\2\2\2")
        buf.write("jh\3\2\2\2jk\3\2\2\2km\3\2\2\2lj\3\2\2\2mn\7\21\2\2n\23")
        buf.write("\3\2\2\2or\5\32\16\2pr\5\26\f\2qo\3\2\2\2qp\3\2\2\2r\25")
        buf.write("\3\2\2\2sz\7\27\2\2tv\t\2\2\2ut\3\2\2\2vw\3\2\2\2wu\3")
        buf.write("\2\2\2wx\3\2\2\2xz\3\2\2\2ys\3\2\2\2yu\3\2\2\2z\27\3\2")
        buf.write("\2\2{~\5\26\f\2|~\5\32\16\2}{\3\2\2\2}|\3\2\2\2~\31\3")
        buf.write("\2\2\2\177\u0080\t\3\2\2\u0080\33\3\2\2\2\24\36 )\60\65")
        buf.write("\67>EHRY]`jqwy}")
        return buf.getvalue()


class NeuralLogParser ( Parser ):

    grammarFileName = "NeuralLog.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'{'", "'..'", "'}'", "'for'", "'in'", 
                     "'do'", "'done'", "'not'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'('", "')'", 
                     "','", "'.'", "'::'", "':-'", "'$'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "FOR_LOOP", "IN_TOKEN", "DO_TOKEN", "DONE_TOKEN", 
                      "NEGATION", "SCIENTIFIC_NUMBER", "DECIMAL", "INTEGER", 
                      "TERM", "PLACE_HOLDER", "OPEN_ARGUMENTS", "CLOSE_ARGUMENTS", 
                      "ITEM_SEPARATOR", "END_OF_CLAUSE", "WEIGHT_SEPARATOR", 
                      "IMPLICATION_SIGN", "TRAINABLE_IDENTIFIER", "QUOTED", 
                      "WHITESPACE", "COMMENT", "BLOCK_COMMENT" ]

    RULE_program = 0
    RULE_for_loop = 1
    RULE_clause = 2
    RULE_atom = 3
    RULE_weighted_atom = 4
    RULE_horn_clause = 5
    RULE_body = 6
    RULE_literal = 7
    RULE_list_of_arguments = 8
    RULE_argument = 9
    RULE_term = 10
    RULE_for_term = 11
    RULE_number = 12

    ruleNames =  [ "program", "for_loop", "clause", "atom", "weighted_atom", 
                   "horn_clause", "body", "literal", "list_of_arguments", 
                   "argument", "term", "for_term", "number" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    FOR_LOOP=4
    IN_TOKEN=5
    DO_TOKEN=6
    DONE_TOKEN=7
    NEGATION=8
    SCIENTIFIC_NUMBER=9
    DECIMAL=10
    INTEGER=11
    TERM=12
    PLACE_HOLDER=13
    OPEN_ARGUMENTS=14
    CLOSE_ARGUMENTS=15
    ITEM_SEPARATOR=16
    END_OF_CLAUSE=17
    WEIGHT_SEPARATOR=18
    IMPLICATION_SIGN=19
    TRAINABLE_IDENTIFIER=20
    QUOTED=21
    WHITESPACE=22
    COMMENT=23
    BLOCK_COMMENT=24

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def for_loop(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeuralLogParser.For_loopContext)
            else:
                return self.getTypedRuleContext(NeuralLogParser.For_loopContext,i)


        def clause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeuralLogParser.ClauseContext)
            else:
                return self.getTypedRuleContext(NeuralLogParser.ClauseContext,i)


        def getRuleIndex(self):
            return NeuralLogParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = NeuralLogParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 30
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << NeuralLogParser.FOR_LOOP) | (1 << NeuralLogParser.SCIENTIFIC_NUMBER) | (1 << NeuralLogParser.DECIMAL) | (1 << NeuralLogParser.INTEGER) | (1 << NeuralLogParser.TERM) | (1 << NeuralLogParser.PLACE_HOLDER))) != 0):
                self.state = 28
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [NeuralLogParser.FOR_LOOP]:
                    self.state = 26
                    self.for_loop()
                    pass
                elif token in [NeuralLogParser.SCIENTIFIC_NUMBER, NeuralLogParser.DECIMAL, NeuralLogParser.INTEGER, NeuralLogParser.TERM, NeuralLogParser.PLACE_HOLDER]:
                    self.state = 27
                    self.clause()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 32
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class For_loopContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR_LOOP(self):
            return self.getToken(NeuralLogParser.FOR_LOOP, 0)

        def TERM(self):
            return self.getToken(NeuralLogParser.TERM, 0)

        def IN_TOKEN(self):
            return self.getToken(NeuralLogParser.IN_TOKEN, 0)

        def DO_TOKEN(self):
            return self.getToken(NeuralLogParser.DO_TOKEN, 0)

        def DONE_TOKEN(self):
            return self.getToken(NeuralLogParser.DONE_TOKEN, 0)

        def INTEGER(self, i:int=None):
            if i is None:
                return self.getTokens(NeuralLogParser.INTEGER)
            else:
                return self.getToken(NeuralLogParser.INTEGER, i)

        def for_loop(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeuralLogParser.For_loopContext)
            else:
                return self.getTypedRuleContext(NeuralLogParser.For_loopContext,i)


        def clause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeuralLogParser.ClauseContext)
            else:
                return self.getTypedRuleContext(NeuralLogParser.ClauseContext,i)


        def for_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeuralLogParser.For_termContext)
            else:
                return self.getTypedRuleContext(NeuralLogParser.For_termContext,i)


        def getRuleIndex(self):
            return NeuralLogParser.RULE_for_loop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFor_loop" ):
                listener.enterFor_loop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFor_loop" ):
                listener.exitFor_loop(self)




    def for_loop(self):

        localctx = NeuralLogParser.For_loopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_for_loop)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 33
            self.match(NeuralLogParser.FOR_LOOP)
            self.state = 34
            self.match(NeuralLogParser.TERM)
            self.state = 35
            self.match(NeuralLogParser.IN_TOKEN)
            self.state = 46
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [NeuralLogParser.SCIENTIFIC_NUMBER, NeuralLogParser.DECIMAL, NeuralLogParser.INTEGER, NeuralLogParser.TERM, NeuralLogParser.PLACE_HOLDER, NeuralLogParser.QUOTED]:
                self.state = 37 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 36
                    self.for_term()
                    self.state = 39 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << NeuralLogParser.SCIENTIFIC_NUMBER) | (1 << NeuralLogParser.DECIMAL) | (1 << NeuralLogParser.INTEGER) | (1 << NeuralLogParser.TERM) | (1 << NeuralLogParser.PLACE_HOLDER) | (1 << NeuralLogParser.QUOTED))) != 0)):
                        break

                pass
            elif token in [NeuralLogParser.T__0]:
                self.state = 41
                self.match(NeuralLogParser.T__0)
                self.state = 42
                self.match(NeuralLogParser.INTEGER)
                self.state = 43
                self.match(NeuralLogParser.T__1)
                self.state = 44
                self.match(NeuralLogParser.INTEGER)
                self.state = 45
                self.match(NeuralLogParser.T__2)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 48
            self.match(NeuralLogParser.DO_TOKEN)
            self.state = 51 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 51
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [NeuralLogParser.FOR_LOOP]:
                    self.state = 49
                    self.for_loop()
                    pass
                elif token in [NeuralLogParser.SCIENTIFIC_NUMBER, NeuralLogParser.DECIMAL, NeuralLogParser.INTEGER, NeuralLogParser.TERM, NeuralLogParser.PLACE_HOLDER]:
                    self.state = 50
                    self.clause()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 53 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << NeuralLogParser.FOR_LOOP) | (1 << NeuralLogParser.SCIENTIFIC_NUMBER) | (1 << NeuralLogParser.DECIMAL) | (1 << NeuralLogParser.INTEGER) | (1 << NeuralLogParser.TERM) | (1 << NeuralLogParser.PLACE_HOLDER))) != 0)):
                    break

            self.state = 55
            self.match(NeuralLogParser.DONE_TOKEN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def END_OF_CLAUSE(self):
            return self.getToken(NeuralLogParser.END_OF_CLAUSE, 0)

        def atom(self):
            return self.getTypedRuleContext(NeuralLogParser.AtomContext,0)


        def weighted_atom(self):
            return self.getTypedRuleContext(NeuralLogParser.Weighted_atomContext,0)


        def horn_clause(self):
            return self.getTypedRuleContext(NeuralLogParser.Horn_clauseContext,0)


        def getRuleIndex(self):
            return NeuralLogParser.RULE_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClause" ):
                listener.enterClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClause" ):
                listener.exitClause(self)




    def clause(self):

        localctx = NeuralLogParser.ClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 60
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.state = 57
                self.atom()
                pass

            elif la_ == 2:
                self.state = 58
                self.weighted_atom()
                pass

            elif la_ == 3:
                self.state = 59
                self.horn_clause()
                pass


            self.state = 62
            self.match(NeuralLogParser.END_OF_CLAUSE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def list_of_arguments(self):
            return self.getTypedRuleContext(NeuralLogParser.List_of_argumentsContext,0)


        def PLACE_HOLDER(self, i:int=None):
            if i is None:
                return self.getTokens(NeuralLogParser.PLACE_HOLDER)
            else:
                return self.getToken(NeuralLogParser.PLACE_HOLDER, i)

        def TERM(self, i:int=None):
            if i is None:
                return self.getTokens(NeuralLogParser.TERM)
            else:
                return self.getToken(NeuralLogParser.TERM, i)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom" ):
                listener.enterAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom" ):
                listener.exitAtom(self)




    def atom(self):

        localctx = NeuralLogParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_atom)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 65 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 64
                _la = self._input.LA(1)
                if not(_la==NeuralLogParser.TERM or _la==NeuralLogParser.PLACE_HOLDER):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 67 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==NeuralLogParser.TERM or _la==NeuralLogParser.PLACE_HOLDER):
                    break

            self.state = 70
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==NeuralLogParser.OPEN_ARGUMENTS:
                self.state = 69
                self.list_of_arguments()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Weighted_atomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(NeuralLogParser.AtomContext,0)


        def number(self):
            return self.getTypedRuleContext(NeuralLogParser.NumberContext,0)


        def WEIGHT_SEPARATOR(self):
            return self.getToken(NeuralLogParser.WEIGHT_SEPARATOR, 0)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_weighted_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeighted_atom" ):
                listener.enterWeighted_atom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeighted_atom" ):
                listener.exitWeighted_atom(self)




    def weighted_atom(self):

        localctx = NeuralLogParser.Weighted_atomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_weighted_atom)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 72
            self.number()
            self.state = 73
            self.match(NeuralLogParser.WEIGHT_SEPARATOR)
            self.state = 75
            self.atom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Horn_clauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(NeuralLogParser.AtomContext,0)


        def IMPLICATION_SIGN(self):
            return self.getToken(NeuralLogParser.IMPLICATION_SIGN, 0)

        def body(self):
            return self.getTypedRuleContext(NeuralLogParser.BodyContext,0)


        def getRuleIndex(self):
            return NeuralLogParser.RULE_horn_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHorn_clause" ):
                listener.enterHorn_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHorn_clause" ):
                listener.exitHorn_clause(self)




    def horn_clause(self):

        localctx = NeuralLogParser.Horn_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_horn_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 77
            self.atom()
            self.state = 78
            self.match(NeuralLogParser.IMPLICATION_SIGN)
            self.state = 80
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << NeuralLogParser.NEGATION) | (1 << NeuralLogParser.TERM) | (1 << NeuralLogParser.PLACE_HOLDER) | (1 << NeuralLogParser.TRAINABLE_IDENTIFIER))) != 0):
                self.state = 79
                self.body()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeuralLogParser.LiteralContext)
            else:
                return self.getTypedRuleContext(NeuralLogParser.LiteralContext,i)


        def ITEM_SEPARATOR(self, i:int=None):
            if i is None:
                return self.getTokens(NeuralLogParser.ITEM_SEPARATOR)
            else:
                return self.getToken(NeuralLogParser.ITEM_SEPARATOR, i)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBody" ):
                listener.enterBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBody" ):
                listener.exitBody(self)




    def body(self):

        localctx = NeuralLogParser.BodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 82
            self.literal()
            self.state = 87
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==NeuralLogParser.ITEM_SEPARATOR:
                self.state = 83
                self.match(NeuralLogParser.ITEM_SEPARATOR)
                self.state = 84
                self.literal()
                self.state = 89
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(NeuralLogParser.AtomContext,0)


        def NEGATION(self):
            return self.getToken(NeuralLogParser.NEGATION, 0)

        def TRAINABLE_IDENTIFIER(self):
            return self.getToken(NeuralLogParser.TRAINABLE_IDENTIFIER, 0)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)




    def literal(self):

        localctx = NeuralLogParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 91
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==NeuralLogParser.NEGATION:
                self.state = 90
                self.match(NeuralLogParser.NEGATION)


            self.state = 94
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==NeuralLogParser.TRAINABLE_IDENTIFIER:
                self.state = 93
                self.match(NeuralLogParser.TRAINABLE_IDENTIFIER)


            self.state = 96
            self.atom()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class List_of_argumentsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_ARGUMENTS(self):
            return self.getToken(NeuralLogParser.OPEN_ARGUMENTS, 0)

        def argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NeuralLogParser.ArgumentContext)
            else:
                return self.getTypedRuleContext(NeuralLogParser.ArgumentContext,i)


        def CLOSE_ARGUMENTS(self):
            return self.getToken(NeuralLogParser.CLOSE_ARGUMENTS, 0)

        def ITEM_SEPARATOR(self, i:int=None):
            if i is None:
                return self.getTokens(NeuralLogParser.ITEM_SEPARATOR)
            else:
                return self.getToken(NeuralLogParser.ITEM_SEPARATOR, i)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_list_of_arguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterList_of_arguments" ):
                listener.enterList_of_arguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitList_of_arguments" ):
                listener.exitList_of_arguments(self)




    def list_of_arguments(self):

        localctx = NeuralLogParser.List_of_argumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_list_of_arguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            self.match(NeuralLogParser.OPEN_ARGUMENTS)
            self.state = 99
            self.argument()
            self.state = 104
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==NeuralLogParser.ITEM_SEPARATOR:
                self.state = 100
                self.match(NeuralLogParser.ITEM_SEPARATOR)
                self.state = 101
                self.argument()
                self.state = 106
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 107
            self.match(NeuralLogParser.CLOSE_ARGUMENTS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self):
            return self.getTypedRuleContext(NeuralLogParser.NumberContext,0)


        def term(self):
            return self.getTypedRuleContext(NeuralLogParser.TermContext,0)


        def getRuleIndex(self):
            return NeuralLogParser.RULE_argument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgument" ):
                listener.enterArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgument" ):
                listener.exitArgument(self)




    def argument(self):

        localctx = NeuralLogParser.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_argument)
        try:
            self.state = 111
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [NeuralLogParser.SCIENTIFIC_NUMBER, NeuralLogParser.DECIMAL, NeuralLogParser.INTEGER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 109
                self.number()
                pass
            elif token in [NeuralLogParser.TERM, NeuralLogParser.PLACE_HOLDER, NeuralLogParser.QUOTED]:
                self.enterOuterAlt(localctx, 2)
                self.state = 110
                self.term()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QUOTED(self):
            return self.getToken(NeuralLogParser.QUOTED, 0)

        def PLACE_HOLDER(self, i:int=None):
            if i is None:
                return self.getTokens(NeuralLogParser.PLACE_HOLDER)
            else:
                return self.getToken(NeuralLogParser.PLACE_HOLDER, i)

        def TERM(self, i:int=None):
            if i is None:
                return self.getTokens(NeuralLogParser.TERM)
            else:
                return self.getToken(NeuralLogParser.TERM, i)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)




    def term(self):

        localctx = NeuralLogParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_term)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [NeuralLogParser.QUOTED]:
                self.state = 113
                self.match(NeuralLogParser.QUOTED)
                pass
            elif token in [NeuralLogParser.TERM, NeuralLogParser.PLACE_HOLDER]:
                self.state = 115 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 114
                        _la = self._input.LA(1)
                        if not(_la==NeuralLogParser.TERM or _la==NeuralLogParser.PLACE_HOLDER):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()

                    else:
                        raise NoViableAltException(self)
                    self.state = 117 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,15,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class For_termContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term(self):
            return self.getTypedRuleContext(NeuralLogParser.TermContext,0)


        def number(self):
            return self.getTypedRuleContext(NeuralLogParser.NumberContext,0)


        def getRuleIndex(self):
            return NeuralLogParser.RULE_for_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFor_term" ):
                listener.enterFor_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFor_term" ):
                listener.exitFor_term(self)




    def for_term(self):

        localctx = NeuralLogParser.For_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_for_term)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [NeuralLogParser.TERM, NeuralLogParser.PLACE_HOLDER, NeuralLogParser.QUOTED]:
                self.state = 121
                self.term()
                pass
            elif token in [NeuralLogParser.SCIENTIFIC_NUMBER, NeuralLogParser.DECIMAL, NeuralLogParser.INTEGER]:
                self.state = 122
                self.number()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCIENTIFIC_NUMBER(self):
            return self.getToken(NeuralLogParser.SCIENTIFIC_NUMBER, 0)

        def DECIMAL(self):
            return self.getToken(NeuralLogParser.DECIMAL, 0)

        def INTEGER(self):
            return self.getToken(NeuralLogParser.INTEGER, 0)

        def getRuleIndex(self):
            return NeuralLogParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)




    def number(self):

        localctx = NeuralLogParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << NeuralLogParser.SCIENTIFIC_NUMBER) | (1 << NeuralLogParser.DECIMAL) | (1 << NeuralLogParser.INTEGER))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx






"""
Represents a graph from a clause.
"""
import logging
from collections import deque
from typing import Dict, List, Set

from src.knowledge.program import ANY_PREDICATE_NAME
from src.language.language import Term, Literal, Atom

logger = logging.getLogger(__name__)


class RulePathFinder:
    """
    Represents a rule graph
    """
    edge_literals: Dict[Term, List[Literal]]
    loop_literals: Dict[Term, List[Literal]]

    def __init__(self, clause):
        """
        Creates a rule graph.

        :param clause: the clause
        :type clause: HornClause
        """
        self.clause = clause
        self._build_graph()

    def _build_graph(self):
        """
        Builds the graph from the clause.

        :return: the graph
        :rtype: dict[Term, list[Literal]]
        """
        self.edge_literals = dict()
        self.loop_literals = dict()
        for literal in self.clause.body:
            arity = literal.arity()
            if arity == 0:
                continue
            elif arity == 1 or literal.terms[0] == literal.terms[-1]:
                self.loop_literals.setdefault(
                    literal.terms[0], []).append(literal)
            else:
                for i in range(arity):
                    self.edge_literals.setdefault(
                        literal.terms[i], []).append(literal)

    def find_clause_paths(self, output_index):
        """
        Finds the paths in the clause.

        :param output_index: the index of the output term
        :type output_index: int
        :return: the rule graph generated by the paths in the clause
        :rtype: RuleGraph
        """
        # Defining variables
        sources = list(self.clause.head.terms)
        compute_reverse = True
        if len(sources) > 1:
            destination = sources.pop(output_index)
        else:
            compute_reverse = False
            destination = sources[0]

        paths = []
        sources_set = set(sources)
        all_visited = set()
        for source in sources:
            visited = set()
            paths += self.find_forward_paths(
                source, destination, visited, sources_set)
            all_visited.update(visited)
        path_set = set(paths)

        if compute_reverse and not all_visited.issuperset(self.clause.body):
            # Finding backward paths
            source = destination
            for destination in sources:
                all_sources = set(self.clause.head.terms)
                all_sources.remove(destination)
                visited = set(all_visited)
                # visited = set()
                backward_paths = self.find_forward_paths(
                    source, destination, visited, all_sources)
                for backward_path in backward_paths:
                    reversed_path = backward_path.reverse()
                    if reversed_path not in path_set:
                        path_set.add(reversed_path)
                        paths.append(reversed_path)
                all_visited.update(visited)

        ground_literals = self.get_disconnected_literals(all_visited)

        # return paths, ground_literals
        return RuleGraph(self.clause, sources, paths, ground_literals)

    def get_disconnected_literals(self, connected_literals):
        """
        Gets the literals from the `clause` which are disconnected from the
        source and destination variables but are grounded.

        :param connected_literals: the set of connected literals
        :type connected_literals: Set[Literal]
        :return: the list of disconnected literals
        :rtype: List[Literal]
        """
        ground_literals = []
        for literal in self.clause.body:
            if literal in connected_literals or not literal.is_grounded():
                continue
            ground_literals.append(literal)
        return ground_literals

    # noinspection DuplicatedCode
    def find_forward_paths(self, source, destination, visited_literals,
                           all_sources=None):
        """
        Finds all forward paths from `source` to `destination` by using the
        literals in the clause.
        If the destination cannot be reached, it includes a special `any`
        predicated to connect the path.

        :param source: the source of the paths
        :type source: Term
        :param destination: the destination of the paths
        :type destination: Term
        :param visited_literals: the set of visited literals
        :type visited_literals: Set[Literal]
        :param all_sources: the set of all sources
        :type all_sources: Set[Term]
        :return: the completed forward paths between source and destination
        :rtype: List[RulePath]
        """
        if all_sources is None:
            all_sources = {source}
        partial_paths = deque()  # type: deque[RulePath]

        initial_path = self.build_initial_path(source, visited_literals)
        for literal in self.edge_literals.get(source, []):
            if literal in visited_literals:
                continue
            new_path = initial_path.new_path_with_item(literal)
            if new_path is not None:
                path_end = new_path.path_end()
                if path_end != source and path_end in all_sources:
                    continue
                visited_literals.add(literal)
                if path_end != destination:
                    for loop in self.loop_literals.get(path_end, []):
                        new_path.append(loop)
                        visited_literals.add(loop)
                partial_paths.append(new_path)
        if len(partial_paths) == 0:
            partial_paths.append(initial_path)

        return self.find_paths(
            partial_paths, destination, visited_literals, all_sources)

    @staticmethod
    def complete_path_with_any(dead_end_paths, destination):
        """
        Completes the path by appending the special `any` predicate between the
        end of the path and the destination.

        :param dead_end_paths: the paths to be completed
        :type dead_end_paths: collections.Iterable[RulePath]
        :param destination: the destination
        :type destination: Term
        :return: the completed paths
        :rtype: List[RulePath]
        """
        completed_paths = []
        for path in dead_end_paths:
            any_literal = Literal(Atom(ANY_PREDICATE_NAME,
                                       path.path_end(), destination))
            path.append(any_literal)
            completed_paths.append(path)
        return completed_paths

    def build_initial_path(self, source, visited_literals):
        """
        Builds a path with its initial literals, if any.

        :param source: the source of the path
        :type source: Term
        :param visited_literals: the set of visited literals
        :type visited_literals: set[Literal]
        :return: the path or `None`
        :rtype: RulePath
        """
        loop_literals = self.loop_literals.get(source, [])
        path = RulePath(source, loop_literals)
        visited_literals.update(path.literals)
        return path

    # noinspection DuplicatedCode
    def find_paths(self, partial_paths, destination, visited_literals,
                   all_sources):
        """
        Finds the paths from `partial_paths` to `destination` by appending the
        literals from clause.

        :param partial_paths: The initial partial paths
        :type partial_paths: deque[RulePath]
        :param destination: the destination term
        :type destination: Term
        :param visited_literals: the visited literals
        :type visited_literals: Set[Literal]
        :param all_sources: the set of all sources
        :type all_sources: Set[Term]
        :return: the completed paths
        :rtype: List[RulePath]
        """
        completed_paths = deque()  # type: deque[RulePath]
        while len(partial_paths) > 0:
            size = len(partial_paths)
            for i in range(size):
                path = partial_paths.popleft()
                path_end = path.path_end()

                if path_end == destination:
                    if path.source != destination:
                        for loop in self.loop_literals.get(destination, []):
                            path.append(loop)
                            visited_literals.add(loop)
                    completed_paths.append(path)
                    continue

                possible_edges = self.edge_literals.get(path_end, [])
                not_added_path = True
                for literal in possible_edges:
                    new_path = path.new_path_with_item(literal)
                    if new_path is None:
                        continue
                    end = new_path.path_end()
                    if end != path.source and end in all_sources:
                        continue
                    if end != destination:
                        for loop in self.loop_literals.get(end, []):
                            new_path.append(loop)
                            visited_literals.add(loop)
                    partial_paths.append(new_path)
                    # noinspection PyTypeChecker
                    visited_literals.add(literal)
                    not_added_path = False

                if not_added_path:
                    if path.source == destination:
                        completed_paths.append(path)
                    else:
                        any_literal = Literal(Atom(
                            ANY_PREDICATE_NAME, path.path_end(), destination))
                        path.append(any_literal)
                        partial_paths.append(path)
        return completed_paths

    def __str__(self):
        return "[{}] {}".format(self.__class__.__name__, self.clause.__str__())

    def __repr__(self):
        return "[{}] {}".format(self.__class__.__name__, self.clause.__repr__())


class RulePath:
    """
    Represents a rule path.
    """

    source: Term
    "The source term"

    path: List[Literal]
    "The path of literals"

    literals: Set[Literal]
    "The set of literals in the path"

    terms: Set[Term]
    "The set of all terms in the path"

    input_indices: List[int]
    "The list with the indices of the input term for each literal."

    output_indices: List[int]
    "The list with the indices of the output term for each literal."

    def __init__(self, source, path=()):
        """
        Initializes a path.

        :param source: The source term
        :type source: Term
        :param path: the path
        :type path: collections.Sequence[Literal]
        """
        self.source = source
        self.path = list()
        self.literals = set()
        self.terms = set()
        self.input_indices = list()
        self.output_indices = list()

        for literal in path:
            self.append(literal)

    def path_end(self):
        """
        Gets the term at the end of the path.

        :return: the term at the end of the path
        :rtype: Term
        """
        if len(self.path) == 0:
            return self.source
        return self.path[-1].terms[self.output_indices[-1]]

    def append(self, item, force_output=None):
        """
        Appends the item to the end of the path, if it is not in the path yet.

        :param item: the item
        :type item: Literal
        :param force_output: forces the output term to be at this index
        :type force_output: int
        :return: True, if the item has been appended to the path; False,
        otherwise.
        :rtype: bool
        """
        if item is None:
            return False

        arity = item.arity()
        path_end = self.path_end()
        if arity == 1:
            input_index = 0
            out_index = 0
        elif arity == 2:
            if item.terms[-1] == path_end:
                # inverted literal case
                input_index = 1
                out_index = 0
                if item.predicate.name == ANY_PREDICATE_NAME:
                    # if the literal is any, reverse the terms and make it
                    # not inverted. Since any^{-1} == any
                    item = Literal(
                        Atom(item.predicate, *list(reversed(item.terms)),
                             weight=item.weight), negated=item.negated)
            else:
                input_index = 0
                out_index = 1
        else:
            # high arity item
            # for now, assumes that the output of a literal with arity bigger
            # than 2 is always the last term
            input_index = item.terms.index(path_end)
            out_index = force_output if force_output is not None else arity - 1

        output_variable = item.terms[out_index]

        # Detects if there is a loop in the path
        # If it is a loop, the path is invalid
        #   assumes that all terms of a literal with arity bigger than two are
        #   all different among each other
        # It also avoids paths return through a literal with arity bigger than 2
        if arity != 1 and \
                item.terms[0] != item.terms[-1] and \
                output_variable in self.terms:
            return False
        if arity > 2 and output_variable == path_end:
            return False

        self.path.append(item)
        self.literals.add(item)
        self.terms.update(item.terms)
        self.input_indices.append(input_index)
        self.output_indices.append(out_index)
        return True

    def new_path_with_item(self, item):
        """
        Creates a new path with `item` at the end.

        :param item: the item
        :type item: Literal or None
        :return: the new path, if its is possible to append the item; None,
        otherwise
        :rtype: RulePath or None
        """
        path = RulePath(self.source, self.path)
        return path if path.append(item) else None

    def all_paths_with_item(self, item):
        """
        Creates all possible new paths with `item` at the end.

        :param item: the item
        :type item: Literal or None
        :return: the new path, if its is possible to append the item; None,
        otherwise
        :rtype: list[RulePath]
        """
        paths = []
        for i in range(len(item.terms)):
            if item.terms[i] == self.path_end():
                continue
            path = RulePath(self.source, self.path)
            if path.append(item, i):
                paths.append(path)
        return paths

    def reverse(self):
        """
        Gets a reverse path.

        :return: the reverse path
        :rtype: RulePath
        """
        source = self.path[-1].terms[self.output_indices[-1]]
        reversed_path = RulePath(source)

        reversed_path.path = list(reversed(self.path))
        reversed_path.literals = set(self.literals)
        reversed_path.terms = set(self.terms)
        reversed_path.input_indices = list(reversed(self.output_indices))
        reversed_path.output_indices = list(reversed(self.input_indices))
        return reversed_path
        # return RulePath2(source, list(reversed(self.path)))

    def __getitem__(self, item):
        return self.path.__getitem__(item)

    def __len__(self):
        return self.path.__len__()

    def __repr__(self):
        message = []
        for i in range(0, len(self.path)):
            prefix = self.path[i].predicate.name
            iterator = list(map(lambda x: x.value, self.path[i].terms))
            if self.input_indices[i] > self.output_indices[i]:
                if self.path[i].predicate.name != ANY_PREDICATE_NAME:
                    prefix += "^{-1}"
                iterator = reversed(iterator)

            prefix += "("
            prefix += ", ".join(iterator)
            prefix += ")"
            message.append(prefix)

        return ", ".join(message)

    def __hash__(self):
        return hash((self.source, tuple(self.path)))

    def __eq__(self, other):
        if not isinstance(other, RulePath):
            return False
        return self.source == other.source and self.path == other.path

    def get_input_term(self, index):
        """
        Returns the input term of the literal at `index`.

        :param index: the index
        :type index: int
        :return: the input term at the index
        :rtype: Term
        """

        return self.path[index].terms[self.input_indices[index]]

    def get_output_term(self, index):
        """
        Returns the output term of the literal at `index`.

        :param index: the index
        :type index: int
        :return: the output term at the index
        :rtype: Term
        """

        return self.path[index].terms[self.output_indices[index]]

    def is_loop(self, index):
        """
        Returns `True` if the literal at `index` is a loop.

        :param index: the index of the literal
        :type index: int
        :return: `True`, if the literal at `index` is a loop; otherwise, `False`
        :rtype: bool
        """
        return self.get_input_term(index) == self.get_output_term(index)


class Edge:
    """
    Represents an edge in the graph.
    """

    def __init__(self, literal, input_indices, output_index):
        """
        Creates the edge.

        :param literal: the literal of the edge
        :type literal: Literal
        :param input_indices: the indices of the input terms
        :type input_indices: tuple[int]
        :param output_index: the index of the output term
        :type output_index: int
        """
        self.literal = literal
        self.input_indices = input_indices
        self.output_index = output_index

    def get_input_terms(self):
        """
        Gets the input term.

        :return: the input term
        :rtype: tuple[Term]
        """
        return tuple(self.literal.terms[i] for i in self.input_indices)

    def get_output_term(self):
        """
        Gets the output term.

        :return: the output term
        :rtype: Term
        """
        return self.literal.terms[self.output_index]

    def is_inverted(self):
        """
        Returns `True` if the edge represents an inverted literal.

        :return:  `True`, if the edge represents an inverted literal;
        otherwise, False
        :rtype: bool
        """
        if len(self.input_indices) > 1:
            return False

        if self.literal.terms[0] == self.literal.terms[-1]:
            return False

        return self.input_indices[0] > self.output_index

    def __lt__(self, other):
        return (self.literal.simple_key(), self.input_indices,
                self.output_index) < (other.literal.simple_key(),
                                      other.input_indices, other.output_index)

    def __hash__(self):
        return hash((self.literal, self.input_indices, self.output_index))

    def __eq__(self, other):
        if not isinstance(other, Edge):
            return False

        if self.literal != other.literal:
            return False

        if self.input_indices != other.input_indices:
            return False

        if self.output_index != other.output_index:
            return False

        return True

    def __str__(self):
        terms = self.get_input_terms()
        if len(terms) > 1:
            terms = "{" + ", ".join(map(lambda x: str(x), terms)) + "}"
        else:
            terms = terms[0]
        return "{} -> {} -> {}".format(
            terms,
            self.literal,
            self.literal.terms[self.output_index]
        )

    def __repr__(self):
        return self.__str__()


def build_edge_for_path(path, index):
    """
    Builds an edge object for the literal of `index` in `path`.

    :param path: the path
    :type path: RulePath
    :param index: the index of the literal
    :type index: int
    :return: the edge
    :rtype: Edge
    """
    literal = path.path[index]
    if literal.arity() > 2:
        input_indices = tuple(range(literal.arity() - 1))
    else:
        input_indices = path.input_indices[index],
    edge = Edge(literal, input_indices, path.output_indices[index])
    return edge, literal


class RuleGraph:
    """
    Represents a rule as a graph.
    """

    sources: List[Term]
    "The list of source terms"

    destinations: List[Term]
    "The destination term"

    edges: Set[Edge]
    "The set of edges"

    input_edges_by_nodes: Dict[Term, List[Edge]]
    "The input literals by term"

    loops_by_nodes: Dict[Term, List[Edge]]
    "The loop literals by term"

    grounds: List[Literal]
    "The grounded terms"

    def __init__(self, clause, sources, paths, grounds):
        """
        Creates a rule graph.

        :param clause: the clause
        :type clause: HornClause
        :param sources: the list of source terms
        :type sources: List[Term]
        :param paths: the completed paths between the terms of the clause
        :type paths: List[RulePath]
        :param grounds: the remaining grounded literals in the clause
        :type grounds: List[Literal]
        """
        self.clause = clause
        self.sources = sources
        self.destinations = list()
        self.edges = set()
        self.input_edges_by_nodes = dict()
        self.loops_by_nodes = dict()
        self.paths = self._build_graph(paths)
        self._merge_any_edges()
        self.grounds = grounds

    def _build_graph(self, paths):
        """
        Builds the graph.

        :param paths: the completed paths between the terms of the clause
        :type paths: List[RulePath]
        :return: the valid paths
        :rtype: List[RulePath]
        """
        destinations = set()
        loops_already_created = set()
        valid_paths = []
        for path in paths:
            path_end = path.path_end()
            if path_end not in destinations:
                destinations.add(path_end)
                self.destinations.append(path_end)
            conflict_literal = self.is_path_valid(path)
            if conflict_literal is not None:
                logger.warning(
                    "Warning: path %s, found in clause %s %s was discarded "
                    "since it passes through a literal in the opposite "
                    "direction of a previously added path. The literal that "
                    "caused the conflict was %s.",
                    path, self.clause, self.clause.provenance, conflict_literal
                )
                continue

            for i in range(len(path)):
                output_term = path.get_output_term(i)
                edge, literal = build_edge_for_path(path, i)
                self.edges.add(edge)
                if path.is_loop(i):
                    if output_term not in loops_already_created:
                        self.loops_by_nodes.setdefault(
                            output_term, []).append(edge)
                else:
                    literals = self.input_edges_by_nodes.setdefault(
                        output_term, [])
                    if edge not in literals:
                        literals.append(edge)
            loops_already_created.update(self.loops_by_nodes.keys())
            valid_paths.append(path)

        return valid_paths

    def is_path_valid(self, path):
        """
        Check if a path is valid.

        A path is `NOT` valid if it tries to pass through a literal in a
        different direction that a previous path has already passed.

        :param path: the path
        :type path: RulePath
        :return: `None`, if the path is valid; otherwise, the first literal
        that caused the conflict.
        :rtype: Literal
        """
        for i in range(len(path)):
            edge, literal = build_edge_for_path(path, i)
            if path.is_loop(i):
                continue
            for output_term in edge.get_input_terms():
                literals = self.input_edges_by_nodes.get(output_term, [])
                for lit in literals:
                    if lit.literal == literal:
                        return literal
        return None

    def _merge_any_edges(self):
        """
        Merge the any predicates to the destination term.
        """

        for term, edges in self.input_edges_by_nodes.items():
            destination_edges = []
            any_inputs = []
            for edge in edges:
                if edge.literal.predicate.name == ANY_PREDICATE_NAME:
                    for input_term in edge.get_input_terms():
                        if input_term not in any_inputs:
                            any_inputs.append(input_term)
                else:
                    destination_edges.append(edge)
            if len(any_inputs) == 0:
                continue
            any_inputs.append(term)
            any_literal = Literal(Atom(ANY_PREDICATE_NAME, *any_inputs))
            last_index = len(any_inputs) - 1
            any_edge = Edge(any_literal, tuple(range(last_index)), last_index)
            destination_edges.append(any_edge)
            self.input_edges_by_nodes[term] = destination_edges

    def __str__(self):
        return "[{}] {}".format(self.__class__.__name__, self.clause.__str__())

    def __repr__(self):
        return "[{}] {}".format(self.__class__.__name__, self.clause.__repr__())
